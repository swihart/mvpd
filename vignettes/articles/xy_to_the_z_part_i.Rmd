---
title: "(XY)^Z Part I"
author: Bruce J. Swihart
date: 2025-05-16
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include=FALSE}
library(mvpd)
```

___ 

**IN PROGRESS**

---

I'm about 8 months late to the party, but a challenge problem from 3blue1brown
caught my attention, as well as a call for intuitive approaches to explaining the result.

> Here's the challenge mode for all you math whizzes. Sample three numbers x, y, z uniformly at random in [0, 1], and compute (xy)^z. What distribution describes this result?
>
> Answer: It's uniform!
>
> I know how to prove it, but haven't yet found the "aha" style explanation where it feels expected or visualizable. If any of you have one, please send it my way and I'll strongly consider making a video on it.
>
> -- Grant Sanderson of 3blue1brown, 2024-09-10


The result and good explanations of the result have been around for a while, as shown in this [Math SE post from 2012](https://math.stackexchange.com/q/261783/180716).  

This [response video by 
Dr Mihai Nica](https://www.youtube.com/watch?v=qNXBwiAsvZM&t=277s) has an explanation that is similar to the one on this page and connects it to Poisson processes and some other statistical results.  I focus more on visualizing the distributions and thinking of the result in terms of convolution and scale mixture, which should be no surprise given these concepts are commonly used in the underlying theory of `mvpd`.  I also generalize the result, showing that the original problem is a specific instance of the more general result.


## Restatement of the Relations

We generalize X, Y being iid Beta($\alpha$, 1) (which for $\alpha=1$ is U(0,1)) and restate the result for the quantity $(XY)^Z$.  We then consider a similar quantity $\left(\frac{1}{XY} \right)^Z$ as well.  For each quantity we build intuition by thinking through the distributions on the log-scale.


---

For iid $X,Y \sim$ Beta($\alpha$, 1) and independent $Z \sim U(0,1)$

**Result 1**:

  * $(XY)^Z  \sim$ Beta($\alpha$, 1)
    * Which implies $Z \left( \log X + \log Y \right) \sim$ ReflectedExp($\alpha$)

**Result 2**:    

  * $\left(\frac{1}{XY} \right)^Z  \sim$ Pareto($x_m=1$, $\alpha_m = \alpha$)
    * Which implies $Z \left( \log \frac{1}{X} + \log \frac{1}{Y} \right) \sim$ Exp($\alpha$)

---

Special instance: For $\alpha = 1$, $X,Y,Z$ and $(XY)^Z  \sim$ U(0,1) (because Beta(1, 1) is U(0,1)).



###  Sanity check: Result 1

Lets do a number of simulations and then plot the quantities to see the theory in action for $(XY)^Z  \sim$ Beta($\alpha$, 1).  We'll plot the theoretical result -- that is, the density that the result says the quantity should take -- in purple on top of the histogram.  First for $\alpha=1$, the special uniform instance (because that is what started it all!) and $\alpha=4.318$ as an arbitrary value bigger than 1 and $\alpha=0.633$ as an arbitrary value smaller than 1.


#### alpha = 1

```{r, fig.show="hold", out.width="50%"}
set.seed(1)
nsims <- 1e4
aa_x <- 1
aa_y <- 1

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)

hist((x*y)^z, breaks=50, freq=FALSE, xlim=c(0,1))
lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     col="purple"
)

hist(x, freq=FALSE, breaks=50, xlim=c(0,1))
lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (x*y)^z

mean(prod)
var(prod)
var(prod) + mean(prod)^2

mean(x)
var(x)
var(x) + mean(x)^2



```

#### alpha = 4.318

```{r, fig.show="hold", out.width="50%", echo=FALSE, results='hide'}
set.seed(1)
nsims <- 1e4
aa_x <- 4.318
aa_y <- 4.318

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)


  
hist((x*y)^z, breaks=50, freq=FALSE, xlim=c(0,1))

lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     col="purple"
)

hist(x, freq=FALSE, breaks=50, xlim=c(0,1))
lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (x*y)^z
mean(prod)
var(prod)
var(prod) + mean(prod)^2


mean(x)
var(x)
var(x) + mean(x)^2



```

#### alpha = 0.633

```{r, fig.show="hold", out.width="50%", echo=FALSE, results='hide'}
set.seed(1)
nsims <- 1e4
aa_x <- 0.633
aa_y <- 0.633

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)


  
hist((x*y)^z, breaks=50, freq=FALSE, xlim=c(0,1))

lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     col="purple"
)

hist(x, freq=FALSE, breaks=50, xlim=c(0,1))
lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (x*y)^z
mean(prod)
var(prod)
var(prod) + mean(prod)^2


mean(x)
var(x)
var(x) + mean(x)^2



```

### Log-scale for intuition building

Consider the log scale, which changes the relation from a product raised to a power into a sum multiplied by a number.  In other words, a convolution (sum of two random variables) and a scale mixture (then multiplied by a random variable).  

We will visualize this using 5 plots arranged in a 3x3 grid.  The left column will show the distributions of each of the 3 components of consideration (log(X), log(Y), and Z), the middle column will just show the convolution of log(X) and log(Y), that is to say log(X)+log(Y), and the third one will show the scale mixture applied to the convolution.  If a line appears on top of the histogram, that's the theoretical result, and the bars falling nicely along the line shows agreement between the simulation and the expected theoretical result.



Take a look at this for alpha=1:

```{r, include=TRUE, eval=TRUE, echo=FALSE}
## okay, just keep it to beta(a,1) with a uniform 
set.seed(1)
nsims <- 1e4
aa_x <- 1
aa_y <- 1

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)

s.xlim <- range(c(log(x),
                  log(y),
                  z,
                  log(x*y),
                  z*log(x*y)
)
) 
s.xlim <- c(-6,0.5)
s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))

dlogbeta<-function(x,a,b) exp(a*x) * (1-exp(x))^(b-1) / beta(a,b)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      col="red"
)

hist(log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_y,
               bb_y),
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0,1.2), xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(x)+log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)+log(Y)", xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(x)+log(y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(X)+log(Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

Quick observations --

  * log(X): is a Reflected Exponential with rate $\alpha$, as is log(Y) *and* Z(log(X)+log(Y))!
    * the bars fall along the red density line
  * log(X) + log(Y): the convolution (i.e., sum) of two Reflected Exponentials is more disperse and squattier than just one Reflected Exponential. We know this already -- think of adding two normals together and the variance of the resultant Normal having the sum of the variances of the original normals.
  * Z(log(X)+log(Y)): to "recover" or "get back to" the original distribution before the convolution, log(X), we need to "tighten" or "gather" or "concentrate" the log(X)+log(Y) distribution. Multiplying it by a random number between 0 and 1 will do exactly that. 
  
See for other values for alpha:

#### alpha = 4.318

```{r, include=TRUE, eval=TRUE, echo=FALSE}
## okay, just keep it to beta(a,1) with a uniform 
set.seed(1)
nsims <- 1e4
aa_x <- 4.318
aa_y <- 4.318

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)

s.xlim <- range(c(log(x),
                  log(y),
                  z,
                  log(x*y),
                  z*log(x*y)
)
) 

s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))
s.xlim <- c(-1.5,0.5)
dlogbeta<-function(x,a,b) exp(a*x) * (1-exp(x))^(b-1) / beta(a,b)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      col="red"
)

hist(log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_y,
               bb_y),
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=s.ylim, xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(x)+log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)+log(Y)", xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(x)+log(y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(X)+log(Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

#### alpha = 0.633

```{r, include=TRUE, eval=TRUE, echo=FALSE}
## okay, just keep it to beta(a,1) with a uniform 
set.seed(1)
nsims <- 1e4
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)

s.xlim <- range(c(log(x),
                  log(y),
                  z,
                  log(x*y),
                  z*log(x*y)
)
) 

s.xlim <- c(-5.133322,0.9999)

s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))
s.ylim <- c(0,0.6)

dlogbeta<-function(x,a,b) exp(a*x) * (1-exp(x))^(b-1) / beta(a,b)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      col="red"
)

hist(log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_y,
               bb_y),
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0,1.2), xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(x)+log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)+log(Y)", xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(x)+log(y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(X)+log(Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```


### Sanity check: Result 2

Now we draw a bunch of random beta and uniform random variables and then plot the quantities to see the theory in action for $\left(\frac{1}{XY} \right)^Z  \sim$ Pareto($x_m=1$, $\alpha_m = \alpha$).  We will plot the theoretical result in purple on top of the histogram. First for $\alpha=1$, the special uniform instance (because that is what started it all for Result 1!) and $\alpha=4.318$ as an arbitrary value bigger than 1 and $\alpha=0.633$ as an arbitrary value smaller than 1.


#### alpha = 1.000

```{r, fig.show="hold", out.width="50%"}
set.seed(1)
nsims <- 1e4
aa_x <- 1
aa_y <- 1

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)

hist((1/x*1/y)^z, breaks=1e4, freq=FALSE, xlim=c(0,15), ylim=c(0,1))

lines(               seq(0,100,0.01),
                     LNPar::dpareto(seq(0,100,0.01),1,alpha=aa_x),
                     type="l",
                     col="purple"
)

hist(1/x, freq=FALSE, breaks=6e4, xlim=c(0,15), ylim=c(0,1))
lines(               seq(0,100,0.01),
                     LNPar::dpareto(seq(0,100,0.01),1,alpha=aa_x),
                     type="l",
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (1/x*1/y)^z
mean(prod)
var(prod)
var(prod) + mean(prod)^2


mean(1/x)
var(1/x)
var(1/x) + mean(1/x)^2


```


#### alpha = 4.318

```{r, fig.show="hold", out.width="50%", echo=FALSE, results='hide'}

set.seed(1)
nsims <- 1e4
aa_x <- 4.318
aa_y <- 4.318

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)


  
hist((1/x*1/y)^z, breaks=30, freq=FALSE, xlim=c(0,3),ylim=c(0,5.0))

lines(               seq(0,10,0.01),
                     LNPar::dpareto(seq(0,10,0.01),1,alpha=aa_x),
                     type="l",
                     col="purple"
)

hist(1/x, freq=FALSE, breaks=50, xlim=c(0,3),ylim=c(0,5.0))
lines(               seq(0,10,0.01),
                     LNPar::dpareto(seq(0,10,0.01),1,alpha=aa_x),
                     type="l",
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (1/x*1/y)^z
mean(prod)
var(prod)
var(prod) + mean(prod)^2


mean(1/x)
var(1/x)
var(1/x) + mean(1/x)^2



```

#### alpha = 0.633

```{r, fig.show="hold", out.width="50%", echo=FALSE, results='hide'}
# tricky to get the binning right for dpareto
#set.seed(103)
#set.seed(207)
set.seed(219)
nsims <- 1e4
aa_x <- 0.633
aa_y <- 0.633

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)


  
hist((1/x*1/y)^z, breaks=1e6, freq=FALSE, xlim=c(0,20), ylim=c(0,0.50))

lines(               seq(0,20,0.01),
                     LNPar::dpareto(seq(0,20,0.01),1,alpha=aa_x),
                     type="l",
                     col="purple"
)

hist(1/x, freq=FALSE, breaks=2e5, xlim=c(0,20), ylim=c(0,0.50))
lines(               seq(0,20,0.01),
                     LNPar::dpareto(seq(0,20,0.01),1,alpha=aa_x),
                     type="l",
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (1/x*1/y)^z
mean(prod)
var(prod)
var(prod) + mean(prod)^2


mean(1/x)
var(1/x)
var(1/x) + mean(1/x)^2



```

### Log-scale for intuition building

Consider the log scale, which changes the relation from a product raised to a power into a sum multiplied by a number.  In other words, a convolution (sum of two random variables) and a scale mixture (then multiplied by a random variable).  

We will visualize this using 5 plots arranged in a 3x3 grid.  The left column will show the distributions of each of the 3 components of consideration (log(X), log(Y), and Z), the middle column will just show the convolution of log(X) and log(Y), that is to say log(X)+log(Y), and the third one will show the scale mixture applied to the convolution.

Take a look at this for alpha=1:

```{r, include=TRUE, eval=TRUE, echo=FALSE}
## sum of two indep exponentials aa_x = aa_y

nsims <- 1e4
aa_x <- 1
aa_y <- 1

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)


s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)
s.xlim <- c(0,6)
s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0,1.2), xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

Quick observations --

  * log(X): is an Exponential($\alpha$), as is log(Y) *and* Z(log(X)+log(Y))!
  * log(X) + log(Y): the convolution (i.e., sum) of two Exponentials is more disperse and squattier. We know this already -- think of adding two normals together and the variance of the resultant Normal having the sum of the variances of the original normals.
  * Z(log(X)+log(Y)): to "recover" or "get back to" the original distribution before the convolution, log(X), we need to "tighten" or "gather" or "concentrate" the log(X)+log(Y) distribution. Multiplying it by a random number between 0 and 1 will do exactly that. 
  
See for other values for alpha:

#### alpha = 4.318

```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- 1e4
aa_x <- 4.318
aa_y <- 4.318

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)


s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)
s.xlim <- c(0,2.0)
s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=s.ylim, xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

#### alpha = 0.633

```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- 1e4
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)


s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)


s.xlim <- c(0,10)
s.ylim <- c(0,0.6)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0,1.2), xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

### Follow-up questions

Follow up questions means we can explore more.  This was a top comment on the response video linked in the intro:

>
>@JobBouwman
>8 months ago
>Adding two exponentials will double the outcome. Then multiplying this with a random uniform scalar between 0 and 1 will on average half the result. 
>
>

This comment in addition to the video helped inspire this document.  The comment in particular inspired two questions of mine.


  * Q: Why "1/2 on average" and not just "1/2 all the time with no variation"?

Let's see what the resultant Z(log(1/X)+log(1/Y)) distribution would look like if we replaced `z<-runif(nsims, 0, 1)` with `z <- rep(1/2, nsims)` in the code. We will see it "concentrates" too much and doesn't recover the distribution of log(1/X) -- the bars go well above the red density line of the exponential:


```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- 1e4
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- rep(1/2, nsims) ##runif(nsims, 0, 1)
#mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)

s.xlim <- c(0,10)
s.ylim <- c(0,0.6)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

# hist(    z , freq=FALSE, breaks=11, ylim=s.ylim, xlim=c(0,1), 
#      main="Z", xlab="",ylab="")
# 
plot(1/2,1, xlim=c(0,1), 
     main="Z", xlab="",ylab="", pch=16)
segments(x0=1/2,x1=1/2, y0=0, y1=1)



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```


  * Q: Ok, so Z has to be random.  But can it be 1/2 on average but with bounds bigger than 0,1 ?

Let's see what the resultant Z(log(1/X)+log(1/Y)) distribution would look like if we replaced `z<-runif(nsims, 0, 1)` with `z<-runif(nsims, -1, 2)` in the code. The mean of Z is 1/2.  However, Z is not bounded between 0 and 1.
Hypothesis: even though this Z will "1/2 on average" it fails to recover the distribution log(1/X) because Z values bigger than 1 fail to "tighten" the distribution. Compounding the problem is that Z values below 0 (negative values) flip/reflect values across the y-axis.  See below:


```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- 1e4
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, -1, 2)
#mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)

s.xlim <- c(-5,10)
s.ylim <- c(0,0.8)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=s.ylim, xlim=c(-1.1,2.1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```



___


So far we have considered cases where the alpha for X and Y are the same and how multiplying (log(1/X)+log(1/Y)) by Z allows one to recover the original distribution of log(1/X) (equivalently, log(1/Y)).  However, if $\alpha_x \neq \alpha_y$, multiplying (log(1/X)+log(1/Y)) by a uniform would not recover the distribution for either log(1/X) or log(1/Y) -- it would be a distribution "in-between" those two distributions -- but not an Exponential with an alpha between $\alpha_x$ and $\alpha_y$.  We consider this "unequal alpha" as a bonus case below.


## Bonus: Unequal alpha cases

Firstly, one may want to consult Wikipedia.

  * [Wikipedia Sum of Two Independent Exponential Random Variables](https://en.wikipedia.org/wiki/Exponential_distribution#Sum_of_two_independent_exponential_random_variables)
  

So, in this setup, there is no *one* distribution to recover since  $\alpha_x \neq \alpha_y$, so trying different distributions for $Z$ leads to different blends of the X,Y distributions for the quantity Z(log(1/X)+log(1/Y)).  

### Z distributed as U(0,1)

  * $Z \sim$ U(0,1)
  * mathematica says I need incomplete gamma. luckily [vincent goulet made one for R](https://search.r-project.org/CRAN/refmans/expint/html/gammainc.html).
  * page 80 green notebook
  * describe what each color density is

```{r, results='hide', echo=FALSE}
## sum of two indep exponentials aa_x != aa_y
## Z is uniform
nsims <- 1e4
aa_x <- 4
aa_y <- 2

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)


s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)

s.xlim <- c(0,3)

s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))
s.ylim
s.xlim

#dlogbeta<-function(x,a,b) exp(a*x) * (1-exp(x))^(b-1) / beta(a,b)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="blue"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_y),
      col="blue"
)

hist(    z , freq=FALSE, breaks=50, ylim=s.ylim, xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")
f_1x_1y <- function(w, m, n){
  
  m*n/(n-m) * (exp(-m*w) - exp(-n*w))
  
}
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      f_1x_1y(seq(s.xlim[1], s.xlim[2],0.01 ),
              aa_x,
              aa_y),
      col="darkorange"
)


plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")


fw_dens <- function(w, m, n){
  
  num = m*n*(expint::gammainc(0,m*w) - expint::gammainc(0, n*w))
  den = m-n
  
  -num/den
  
}

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      fw_dens(seq(s.xlim[1], s.xlim[2],0.01 ),
              aa_x,
              aa_y),
      col="magenta"
)


plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")


```


### Z distributed as Inverse-Gamma(alpha, beta)

  * $Z \sim$ Inverse-Gamma($alpha_z$, $beta_z$)
  * page 83 green notebook
  * as $\alpha_z = \beta_z >>>> 1$ Z converges on 1 and the distributions look more similar 
  * describe what each color of density is
  
```{r, results='hide', echo=FALSE}
## sum of two indep exponentials aa_x != aa_y
## and z ~ IG(a_z, b_z)

nsims <- 1e4
aa_x <- 4
aa_y <- 2

bb_x <- 1
bb_y <- 1

aa_z <- 3
bb_z <- .9

x <- rbeta (nsims, aa_x, bb_x)
y <- rbeta (nsims, aa_y, bb_y)
z <- invgamma::rinvgamma(nsims, shape=aa_z, rate=bb_z)


s.xlim <- c(0,3)
#   range(c(log(1/x),
#                   log(1/y),
#                   z,
#                   log(1/x * 1/y),
#                   z*log(1/x*1/y)
# )) 
#c(-10,0)
#c(-4,2)

s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))
s.ylim
s.xlim

#dlogbeta<-function(x,a,b) exp(a*x) * (1-exp(x))^(b-1) / beta(a,b)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="blue"
)


hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_y),
      col="blue"
)

hist(    z , freq=FALSE, breaks=50, ylim=s.ylim, xlim=c(0,4), 
     main="Z", xlab="",ylab="")


plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=500, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")

f_1x_1y <- function(w, m, n){
  
  m*n/(n-m) * (exp(-m*w) - exp(-n*w))
  
}

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      f_1x_1y(seq(s.xlim[1], s.xlim[2],0.01 ),
              aa_x,
              aa_y),
      col="darkorange"
)


plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=500, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")


fw_dens_ig <- function(w, m, n, o, p){
  
  fac1 <- (m*n) / (n-m)
  fac2 <- p^o * gamma(o+1) / gamma(o)
  fac3 <- (1/(m*w+p)^(o+1) - 1/(n*w+p)^(o+1))
  
  fac1*fac2*fac3
  
}

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      fw_dens_ig(seq(s.xlim[1], s.xlim[2],0.01 ),
              aa_x,
              aa_y,
              aa_z,
              bb_z),
      col="magenta"
)


plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
```
  
### Z distributed as Pareto  

  * TBD. don't have R code yet.  see page 81 green notebook












  
##  Bonus: What about 3 exponentials?

Let's see what the resultant Z(log(1/X)+log(1/Y)+log(1/A)) distribution would look like, with X,Y,A as iid beta(0.633,1) and an independent Z iid U(0,1)

```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- 1e4
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)

z <- runif(nsims, 0, 1)
#mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)

s.ylim <- c(0,0.6)
s.xlim <- c(0,12)
par(mfcol=c(4,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(-0.1,1.1), xlim=c(-0.1,1.1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)+log(1/A)", xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y)+log(1/A))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

It looks like we need more tightening. Let's tinker.  Instead of multiplying by 1/2 on average, perhaps we need to multiply by 1/3 on average?  Let's leave Z as a uniform, with positive values smaller than 1 that average to a 1/3.  Let's replace `z<-runif(nsims, 0, 1)` with `z<-runif(nsims, 0, 2/3)` in the code:

```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- 1e4
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)

z <- runif(nsims, 0, 2/3)
mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)

s.ylim <- c(0,0.6)
s.xlim <- c(0,12)
par(mfcol=c(4,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0.0,2.0), xlim=c(-0.1,1.1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)+log(1/A)", xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y)+log(1/A))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

While that was fun, this modification (shortening the range of the uniform) does not quite seem to "recover" the distribution of log(1/x).  

This is where turning to theory might save us some time.

The sum of 3 iid Exponential($\alpha$) variables will be distributed as Gamma(3,alpha).

If Q ~ Gamma(3,alpha) then what do we multiply by Q to get an exponential? 
A: P

>A Gamma distribution times a Gamma distribution will result in an exponential distribution if the shape parameter of both Gamma distributions is 1, and their rate parameters are the same. In other words, if X ~ Gamma(1, λ) and Y ~ Gamma(1, λ), then their product X*Y ~ Exponential(λ). 

And 

>Solution:            \(Gamma(3,\alpha )\) cannot be transformed into \(Exponential(\alpha )\). \(Gamma(1,\alpha )\) is equal to \(Exponential(\alpha )\).

One can tinker and see how close they can get but the theory says it will be inexact.


  * go through green books examples of trying to isolate the 'x' and showing that it is going to show up either way for n=3 and then plot!


```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- 1e4 ##6e5
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)

z <- runif(nsims,0,1)
#z <- rgamma(nsims, 0.9, 3)
##z <- rgamma(nsims, 3, aa_x)
#z <- invgamma::rinvgamma(nsims, 3, aa_x)
mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)


s.ylim <- c(0,0.6)
s.xlim <- c(0,12)

par(mfcol=c(4,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0,1.2), xlim=c(-0.1,1.1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)+log(1/A)", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
           3,
           aa_x),
      col="limegreen"
)



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y)+log(1/A))", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="red"
)




lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      0.5*(1+aa_x*seq(s.xlim[1], s.xlim[2],0.01 )) * 
        dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      col="blue"
)


plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```



#### Miscellany / Notes to self / Stubs for future ideas

  *   [Proof of -ln(X) being an Exponential](https://math.stackexchange.com/a/3173387/180716)

  * [Is this transformation of beta relevant for a=0, b=1?](https://math.stackexchange.com/a/4039033/180716)
  
  * [Keep in back pocket for generalizing Uniform...U(-1,1)](https://stats.stackexchange.com/a/461337/35034)

  * Looking at the [inductive form](https://math.stackexchange.com/a/3485159/180716), may provide insight as to why Z may not have a "recovering" distribution for a sum of more than 2 exponentials.
