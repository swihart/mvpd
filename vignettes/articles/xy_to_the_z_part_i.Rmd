---
title: "(XY)^Z Part I"
author: Bruce J. Swihart
date: 2025-05-16
---







```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
nsim.switch <- 1e4
overlaid.dens.lwd <- 3
## https://stackoverflow.com/a/57157075/2727349
safe_colorblind_palette <- c("#88CCEE", "#CC6677", "#DDCC77", 
                             "#117733", "#332288", "#AA4499", 
                             "#44AA99", "#999933", "#882255", 
                             "#661100", "#6699CC", "#888888")
scales::show_col(safe_colorblind_palette)


```

```{r setup, include=FALSE}
library(mvpd)
```

___ 

**IN PROGRESS**

---

I'm about 8 months late to the party, but a challenge problem from 3blue1brown
caught my attention, as well as a call for intuitive approaches to explaining the result.

> Here's the challenge mode for all you math whizzes. Sample three numbers x, y, z uniformly at random in [0, 1], and compute (xy)^z. What distribution describes this result?
>
> Answer: It's uniform!
>
> I know how to prove it, but haven't yet found the "aha" style explanation where it feels expected or visualizable. If any of you have one, please send it my way and I'll strongly consider making a video on it.
>
> -- Grant Sanderson of 3blue1brown, 2024-09-10


While this relation and proofs of the result have been around for a while, as shown in this [Math SE post from 2012](https://math.stackexchange.com/q/261783/180716), the renewed notoriety is how it caught my attention -- and even then 8 months after the fact.  I agree none of the suggested proofs have a slam-dunk visualization.

This [response video by 
Dr Mihai Nica](https://www.youtube.com/watch?v=qNXBwiAsvZM&t=277s) includes an explanation has some similarities to the approaches on this page and connects it to Poisson processes and some other statistical results.  I focus more on visualizing the distributions and thinking of the result in terms of convolution and scale mixture, which should be no surprise given these concepts are commonly used in the underlying theory of `mvpd`.  I also generalize the result, showing that the original problem is a specific instance of this more general result.


## Restatement of the Relations

### Overview Sketch

The original problem could be stated as:

If

  * X ~ U(0,1)
  * Y ~ U(0,1)
  * Z ~ U(0,1) 

Then

  * (XY)^Z ~ U(0,1)

We first note that Beta($\alpha$, 1) is a generalization of the U(0,1).  For $\alpha=1$, Beta(1,1) is the same as U(0,1).  I had a hunch the result would generalize, so for $\alpha > 0$, we state:

If

  * X ~ Beta($\alpha$, 1)
  * Y ~ Beta($\alpha$, 1)
  * Z ~ U(0,1), 
  
Then

  * (XY)^Z ~ Beta($\alpha$, 1)

We then can generalize the distribution of Z to Beta(1, K-1), where K is the number of random variates being multiplied.  In the original problem, K=2, because X and Y were being multiplied and raised to Z.  Well, for K=2, Beta(1,K-1) is Beta(1,1) which is U(0,1).  That leaves us with:

If

  * $X_1$ ~ Beta($\alpha$, 1)
  * $X_2$ ~ Beta($\alpha$, 1)
  * ...
  * $X_K$ ~ Beta($\alpha$, 1)
  
  * $Z$ ~ Beta(1, K-1)

Then

  * $\left(X_1 X_2 \dots X_K \right)^Z$ ~ Beta($\alpha$, 1)

Turns out there is another computed quantity with a distribution:

  * $\left( \frac{1}{X_1 X_2 \dots X_K} \right)^Z$ ~ Pareto(scale = 1, shape=$\alpha$)

We will make pictures of these computed quantities to show they follow these distributions in a bit. While they are useful, they are more confirmatory than intuition building.

For building intuition, I view things on the **log-scale**, which changes the computed quantities from **a product raised to a power** to **a sum multiplied by a scalar**.  Since these are random variables, this amounts to a convolution and then a change of scale (aka "scale mixtures"). 
As one can see, this challenge problem is right up `mvpd`'s alley!  

Going forward, it may be useful to know that

If

  * X ~ Beta($\alpha$, 1) 

Then 

  * $\log(X)$ ~ ReflectedExp($\alpha$)
  * $\sum_{k=1}^K  \log(X_k)$ ~ ReflectedGamma(K, $\alpha$)

and  

  * $\log(\frac{1}{X})$ = $-\log(X)$ ~ Exp($\alpha$) 
  * $\sum_{k=1}^K -\log(X_k)$ ~ Gamma(K, $\alpha$)

As well as 

  * If $u_1, u_2, u_3, \dots u_K$ iid U(0,1) then min($u_1, u_2, u_3, \dots u_K$) ~ Beta(1,K-1).


We'll make lots of pictures of these down below.  Quickly, I'll state what we are showing with those pictures.

> In short, for intuition, the sum of a bunch of exponentials is a gamma, and to recover the original exponential distribution, the sum is multiplied by a beta.

Well, that's the way you'd say it at coffee before a seminar to seem cool.  The parts that fill it in a bit more:

> In short, for intuition, the sum of K iid exponential random variables with common rate $\alpha$ is a gamma(K,$\alpha$). To recover the original exponential distribution, the sum is multiplied by a beta(1, K-1) random variable.

For those that would like a density argument:

 * The sum S~Gamma(K,$\alpha$) has density $f(x) = \frac{\alpha^K}{\Gamma(K)} x^{K-1} \exp(-\alpha x)$
 
 * The product ZS ~ Gamma(K, $\alpha$/Z) has density $f(x) = \frac{(\alpha/Z)^K}{\Gamma(K)} x^{K-1} \exp(-(\alpha/Z) x)$
 
 * Since Z is random we want to integrate it out with respect to its distribution.  So the puzzle becomes for what $f_z$ does the integral solve to the exponential density $f(x) = \alpha \exp(-\alpha x)$?
 
 * $\int f_x f_z dz$ = $\int f(x) = \frac{(\alpha/Z)^K}{\Gamma(K)} x^{K-1} \exp(-(\alpha/Z) x) f_z dz$

 * If $f_z(z) = \frac{(1-z)^{K-2}}{B(1,K-1)}$, then 
   * $\int f_x f_z dz$ = $\int \frac{(\alpha/Z)^K}{\Gamma(K-1)\Gamma(1)} x^{K-1} \exp(-(\alpha/Z) x) (1-z)^{K-2} dz$ = 
   * $\frac{x^{K-1}}{\Gamma(K-1)}  \int (\alpha/Z)^K \exp(-(\alpha/Z) x) (1-z)^{K-2} dz$ =
   * $\frac{x^{K-1}}{\Gamma(K-1)} \left( \alpha \exp(-\alpha x) \frac{\Gamma(K-1)}{x^{K+1}}  \right)$ =
   * $\alpha \exp(-\alpha x) ~~\blacksquare$ 



In closing, we generalize X, Y being iid Beta($\alpha$, 1) (which for $\alpha=1$ is U(0,1)) and restate the result for the computed quantity $(XY)^Z$.  We then consider a similar, computed quantity $\left(\frac{1}{XY} \right)^Z$ as well.  For each quantity we build intuition by thinking through the distributions on the log-scale.


## Concise statements

--------------------------------------------

Result 1 and 2 generalizes the U(0,1) of the X, Y, and (XY)^Z to Beta($\alpha$, 1).

For iid $X,Y \sim$ Beta($\alpha$, 1) and independent $Z \sim U(0,1)$

**Result 1**:

  * $(XY)^Z  \sim$ Beta($\alpha$, 1)
    * Which implies $Z \left( \log X + \log Y \right) \sim$ ReflectedExp($\alpha$)

**Result 2**:    

  * $\left(\frac{1}{XY} \right)^Z  \sim$ Pareto($x_m=1$, $\alpha_m = \alpha$)
    * Which implies $Z \left( \log \frac{1}{X} + \log \frac{1}{Y} \right) \sim$ Exp($\alpha$)

The original challenge problem is the special  $\alpha = 1$ instance: $X,Y,Z$ and $(XY)^Z  \sim$ U(0,1) (because Beta(1, 1) is U(0,1)).

Result 1-K and 2-K generalizes the U(0,1) of the Z to Beta(1, K-1).

For iid $X_k \sim$ Beta($\alpha$, 1), $k=1,...,K, K \in {1,2,...}$ and independent $Z \sim Beta(1,K-1)$

**Result 1-K**:

  * $(\prod X_k)^Z  \sim$ Beta($\alpha$, 1)
    * Which implies $Z \left( \sum \log X_k \right) \sim$ ReflectedExp($\alpha$)

**Result 2-K**:    

  * $\left( \prod \frac{1}{X_k} \right)^Z  \sim$ Pareto($x_m=1$, $\alpha_m = \alpha$)
    * Which implies $Z \left( \sum \log \frac{1}{X_k} \right) \sim$ Exp($\alpha$)

The original challenge problem is the special $\alpha = 1$ and $K=2$ instance: $X,Y,Z$ and $(XY)^Z  \sim$ U(0,1) (because Beta(1, 1) is U(0,1)).

Also note this holds for K=1 because Beta(1,0) is the point mass (constant) 1 (in limit -- see .Rmd for code).

```{r, include=FALSE, echo=FALSE, eval=FALSE}
## see how Beta(1,0) is essentially 1.
## take limit of beta(1,n) n -> 0 ... is it 1?

BETAPARM <- 0.00001;

hist(rbeta(1e4, 1, BETAPARM), freq=FALSE, ylim=c(0,5))


gamma(1+BETAPARM) 
gamma(1)
gamma(BETAPARM)


xval <- 0.99
gamma(1+BETAPARM)/(gamma(1)*gamma(BETAPARM)) * (1-xval)^(BETAPARM - 1)
```


###  Sanity check: Result 1

Lets do a number of simulations and then plot the quantities to see the theory in action for $(XY)^Z  \sim$ Beta($\alpha$, 1).  That is, we will draw `r scales::comma(nsim.switch)` random 
variates of each X, Y, and Z, plot density histograms of those draws and of combinations of those draws.  (Quick note: One can increase this number in the .Rmd file linked below the title by changing the global variable `nsim.switch`.  I kept it moderate for web building/loading purposes; cranking it up allows the barplots to more accurately "fall in line" with the overlaid density.)

We will also overlay the theoretical result -- that is, the density that the mathematical/statistical theory says the quantity should take -- in purple on top of the histogram.  First for $\alpha=1$, the special uniform instance (because that is what started it all!) and $\alpha=4.318$ as an arbitrary value bigger than 1 and $\alpha=0.633$ as an arbitrary value smaller than 1.


#### alpha = 1

```{r, fig.show="hold", out.width="50%"}
set.seed(1)
nsims <- nsim.switch
aa_x <- 1
aa_y <- 1

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)

hist((x*y)^z, breaks=50, freq=FALSE, xlim=c(0,1))
lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

hist(x, freq=FALSE, breaks=50, xlim=c(0,1))
lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (x*y)^z

mean(prod)
var(prod)
var(prod) + mean(prod)^2

mean(x)
var(x)
var(x) + mean(x)^2



```

#### alpha = 4.318

```{r, fig.show="hold", out.width="50%", echo=FALSE, results='hide'}
set.seed(1)
nsims <- nsim.switch
aa_x <- 4.318
aa_y <- 4.318

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)


  
hist((x*y)^z, breaks=50, freq=FALSE, xlim=c(0,1))

lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

hist(x, freq=FALSE, breaks=50, xlim=c(0,1))
lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (x*y)^z
mean(prod)
var(prod)
var(prod) + mean(prod)^2


mean(x)
var(x)
var(x) + mean(x)^2



```

#### alpha = 0.633

```{r, fig.show="hold", out.width="50%", echo=FALSE, results='hide'}
set.seed(1)
nsims <- nsim.switch
aa_x <- 0.633
aa_y <- 0.633

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)


  
hist((x*y)^z, breaks=50, freq=FALSE, xlim=c(0,1))

lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

hist(x, freq=FALSE, breaks=50, xlim=c(0,1))
lines(               seq(0,1,0.01),
                     dbeta(seq(0,1,0.01),aa_x,1),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (x*y)^z
mean(prod)
var(prod)
var(prod) + mean(prod)^2


mean(x)
var(x)
var(x) + mean(x)^2



```

### Log-scale for intuition building

Consider the log scale, which changes the relation from a product raised to a power into a sum multiplied by a number.  In other words, a convolution (sum of two random variables) and a scale mixture (then multiplied by a random variable).  

We will visualize this using 5 plots arranged in a 3x3 grid.  The left column will show the distributions of each of the 3 components of consideration (log(X), log(Y), and Z), the middle column will just show the convolution of log(X) and log(Y), that is to say log(X)+log(Y), and the third one will show the scale mixture applied to the convolution.  If a line appears on top of the histogram, that's the theoretical result, and the bars falling nicely along the line shows agreement between the simulation and the expected theoretical result.



Take a look at this for alpha=1:

```{r, include=TRUE, eval=TRUE, echo=FALSE}
## okay, just keep it to beta(a,1) with a uniform 
set.seed(1)
nsims <- nsim.switch
aa_x <- 1
aa_y <- 1

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)

s.xlim <- range(c(log(x),
                  log(y),
                  z,
                  log(x*y),
                  z*log(x*y)
)
) 
s.xlim <- c(-6,0.5)
s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))

dlogbeta<-function(x,a,b) exp(a*x) * (1-exp(x))^(b-1) / beta(a,b)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_y,
               bb_y),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0,1.2), xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(x)+log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)+log(Y)", xlab="",ylab="")

## reflected gamma -- using math to "hack" dgamma()
lines( rev(seq(s.xlim[1], s.xlim[2],0.01 )),
      dgamma(-rev(seq(s.xlim[1], s.xlim[2],0.01 )),
               2,
               aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(x)+log(y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(X)+log(Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

Quick observations --

  * log(X): is a Reflected Exponential with rate $\alpha$, as is log(Y) *and* Z(log(X)+log(Y))!
    * the bars fall along the red density line
  * log(X) + log(Y): the convolution (i.e., sum) of two Reflected Exponentials is more disperse and squattier than just one Reflected Exponential. We know this already -- think of adding two normals together and the variance of the resultant Normal having the sum of the variances of the original normals.
    * the bars fall along a RefelectedGamma(2,$\alpha$) density
  * Z(log(X)+log(Y)): to "recover" or "get back to" the original distribution before the convolution, log(X), we need to "tighten" or "gather" or "concentrate" the log(X)+log(Y) distribution. Multiplying it by a random number between 0 and 1 will do exactly that. 
  
See for other values for alpha:

#### alpha = 4.318

```{r, include=TRUE, eval=TRUE, echo=FALSE}
## okay, just keep it to beta(a,1) with a uniform 
set.seed(1)
nsims <- nsim.switch
aa_x <- 4.318
aa_y <- 4.318

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)

s.xlim <- range(c(log(x),
                  log(y),
                  z,
                  log(x*y),
                  z*log(x*y)
)
) 

s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))
s.xlim <- c(-1.5,0.5)
dlogbeta<-function(x,a,b) exp(a*x) * (1-exp(x))^(b-1) / beta(a,b)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_y,
               bb_y),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=s.ylim, xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(x)+log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)+log(Y)", xlab="",ylab="")

## reflected gamma -- using math to "hack" dgamma()
lines( rev(seq(s.xlim[1], s.xlim[2],0.01 )),
      dgamma(-rev(seq(s.xlim[1], s.xlim[2],0.01 )),
               2,
               aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(x)+log(y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(X)+log(Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

#### alpha = 0.633

```{r, include=TRUE, eval=TRUE, echo=FALSE}
## okay, just keep it to beta(a,1) with a uniform 
set.seed(1)
nsims <- nsim.switch
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)

s.xlim <- range(c(log(x),
                  log(y),
                  z,
                  log(x*y),
                  z*log(x*y)
)
) 

s.xlim <- c(-5.133322,0.9999)

s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))
s.ylim <- c(0,0.6)

dlogbeta<-function(x,a,b) exp(a*x) * (1-exp(x))^(b-1) / beta(a,b)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_y,
               bb_y),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0,1.2), xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(x)+log(y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(X)+log(Y)", xlab="",ylab="")

## reflected gamma -- using math to "hack" dgamma()
lines( rev(seq(s.xlim[1], s.xlim[2],0.01 )),
      dgamma(-rev(seq(s.xlim[1], s.xlim[2],0.01 )),
               2,
               aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(x)+log(y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(X)+log(Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dlogbeta(seq(s.xlim[1], s.xlim[2],0.01 ),
               aa_x,
               bb_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```


### Sanity check: Result 2

Now we draw a bunch of random beta and uniform random variables and then plot the quantities to see the theory in action for $\left(\frac{1}{XY} \right)^Z  \sim$ Pareto(scale$=1$, shape$= \alpha$).  We will plot the theoretical result in purple on top of the histogram. First for $\alpha=1$, the special uniform instance (because that is what started it all for Result 1!) and $\alpha=4.318$ as an arbitrary value bigger than 1 and $\alpha=0.633$ as an arbitrary value smaller than 1.


#### alpha = 1.000

```{r, fig.show="hold", out.width="50%"}
set.seed(1)
nsims <- nsim.switch
aa_x <- 1
aa_y <- 1

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)

hist((1/x*1/y)^z, breaks=nsim.switch, freq=FALSE, xlim=c(0,15), ylim=c(0,1))

lines(               seq(0,100,0.01),
                     LNPar::dpareto(seq(0,100,0.01),1,alpha=aa_x),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

hist(1/x, freq=FALSE, breaks=6e4, xlim=c(0,15), ylim=c(0,1))
lines(               seq(0,100,0.01),
                     LNPar::dpareto(seq(0,100,0.01),1,alpha=aa_x),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (1/x*1/y)^z
mean(prod)
var(prod)
var(prod) + mean(prod)^2


mean(1/x)
var(1/x)
var(1/x) + mean(1/x)^2


```


#### alpha = 4.318

```{r, fig.show="hold", out.width="50%", echo=FALSE, results='hide'}

set.seed(1)
nsims <- nsim.switch
aa_x <- 4.318
aa_y <- 4.318

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)


  
hist((1/x*1/y)^z, breaks=30, freq=FALSE, xlim=c(0,3),ylim=c(0,5.0))

lines(               seq(0,10,0.01),
                     LNPar::dpareto(seq(0,10,0.01),1,alpha=aa_x),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

hist(1/x, freq=FALSE, breaks=50, xlim=c(0,3),ylim=c(0,5.0))
lines(               seq(0,10,0.01),
                     LNPar::dpareto(seq(0,10,0.01),1,alpha=aa_x),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (1/x*1/y)^z
mean(prod)
var(prod)
var(prod) + mean(prod)^2


mean(1/x)
var(1/x)
var(1/x) + mean(1/x)^2



```

#### alpha = 0.633

```{r, fig.show="hold", out.width="50%", echo=FALSE, results='hide'}
# tricky to get the binning right for dpareto
#set.seed(103)
#set.seed(207)
set.seed(219)
nsims <- nsim.switch
aa_x <- 0.633
aa_y <- 0.633

x <- rbeta(nsims,aa_x,1) ##runif(nsims,0,1)
y <- rbeta(nsims,aa_y,1) ##runif(nsims,0,1)
z <- runif(nsims,0,1)


  
hist((1/x*1/y)^z, breaks=1e6, freq=FALSE, xlim=c(0,20), ylim=c(0,0.50))

lines(               seq(0,20,0.01),
                     LNPar::dpareto(seq(0,20,0.01),1,alpha=aa_x),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

hist(1/x, freq=FALSE, breaks=2e5, xlim=c(0,20), ylim=c(0,0.50))
lines(               seq(0,20,0.01),
                     LNPar::dpareto(seq(0,20,0.01),1,alpha=aa_x),
                     type="l",
                     lwd=overlaid.dens.lwd,
                     col="purple"
)

## compare mean, variance, and 2nd moment
prod <- (1/x*1/y)^z
mean(prod)
var(prod)
var(prod) + mean(prod)^2


mean(1/x)
var(1/x)
var(1/x) + mean(1/x)^2



```

### Log-scale for intuition building

Consider the log scale, which changes the relation from a product raised to a power into a sum multiplied by a number.  In other words, a convolution (sum of two random variables) and a scale mixture (then multiplied by a random variable).  

We will visualize this using 5 plots arranged in a 3x3 grid.  The left column will show the distributions of each of the 3 components of consideration (log(X), log(Y), and Z), the middle column will just show the convolution of log(X) and log(Y), that is to say log(X)+log(Y), and the third one will show the scale mixture applied to the convolution.

Take a look at this for alpha=1:

```{r, include=TRUE, eval=TRUE, echo=FALSE}
## sum of two indep exponentials aa_x = aa_y

nsims <- nsim.switch
aa_x <- 1
aa_y <- 1

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)


s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)
s.xlim <- c(0,6)
s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0,1.2), xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")
##  gamma -- dgamma()
lines( seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
               2,
               aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

Quick observations --

  * log(X): is an Exponential($\alpha$), as is log(Y) *and* Z(log(X)+log(Y))!
  * log(X) + log(Y): the convolution (i.e., sum) of two Exponentials is more disperse and squattier. We know this already -- think of adding two normals together and the variance of the resultant Normal having the sum of the variances of the original normals.
    * the bars fall along a Gamma(2,$\alpha$) density  
  * Z(log(X)+log(Y)): to "recover" or "get back to" the original distribution before the convolution, log(X), we need to "tighten" or "gather" or "concentrate" the log(X)+log(Y) distribution. Multiplying it by a random number between 0 and 1 will do exactly that. 
  
See for other values for alpha:

#### alpha = 4.318

```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch
aa_x <- 4.318
aa_y <- 4.318

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)


s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)
s.xlim <- c(0,2.0)
s.ylim <- c(0, max(dbeta(seq(s.xlim[1],s.xlim[2],0.01), aa_x, bb_x)))

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=s.ylim, xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")
##  gamma -- dgamma()
lines( seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
               2,
               aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

#### alpha = 0.633

```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, 0, 1)


s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)


s.xlim <- c(0,10)
s.ylim <- c(0,0.6)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0,1.2), xlim=c(0,1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")
##  gamma -- dgamma()
lines( seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
               2,
               aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

### Follow-up questions

Follow up questions means we can explore more.  This was a top comment on the response video linked in the intro:

>
>@JobBouwman
>8 months ago
>Adding two exponentials will double the outcome. Then multiplying this with a random uniform scalar between 0 and 1 will on average half the result. 
>
>

This comment in addition to the video helped inspire this document.  The comment in particular inspired two questions of mine.


  * Q: Why "1/2 on average" and not just "1/2 all the time with no variation"?

Let's see what the resultant Z(log(1/X)+log(1/Y)) distribution would look like if we replaced `z<-runif(nsims, 0, 1)` with `z <- rep(1/2, nsims)` in the code. We will see it "concentrates" too much and doesn't recover the distribution of log(1/X) -- the bars go well above the red density line of the exponential:


```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- rep(1/2, nsims) ##runif(nsims, 0, 1)
#mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)

s.xlim <- c(0,10)
s.ylim <- c(0,0.6)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

# hist(    z , freq=FALSE, breaks=11, ylim=s.ylim, xlim=c(0,1), 
#      main="Z", xlab="",ylab="")
# 
plot(1/2,1, xlim=c(0,1), 
     main="Z", xlab="",ylab="", pch=16)
segments(x0=1/2,x1=1/2, y0=0, y1=1)



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")
##  gamma -- dgamma()
lines( seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
               2,
               aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```


  * Q: Ok, so Z has to be random.  But can it be 1/2 on average but with bounds bigger than 0,1 ?

Let's see what the resultant Z(log(1/X)+log(1/Y)) distribution would look like if we replaced `z<-runif(nsims, 0, 1)` with `z<-runif(nsims, -1, 2)` in the code. The mean of Z is 1/2.  However, Z is not bounded between 0 and 1.
Hypothesis: even though this Z will "1/2 on average" it fails to recover the distribution log(1/X) because Z values bigger than 1 fail to "tighten" the distribution. Compounding the problem is that Z values below 0 (negative values) flip/reflect values across the y-axis.  See below:


```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
z <- runif(nsims, -1, 2)
#mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)

s.xlim <- c(-5,10)
s.ylim <- c(0,0.8)

par(mfcol=c(3,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=s.ylim, xlim=c(-1.1,2.1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(log(1/x)+log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)", xlab="",ylab="")
##  gamma -- dgamma()
lines( seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
               2,
               aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
hist(z*(log(1/x)+log(1/y)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```



___


  
##  Bonus: What about 3 exponentials?

We have already stated Results 1-K and 2-K which generalized things to summing K exponentials.  However, let's build some intuition pretending we did not have
those results and just tried to add a 3rd variable to the procedure we have been doing to this point.

Let's see what the resultant Z(log(1/X)+log(1/Y)+log(1/A)) distribution would look like, with X,Y,A as iid beta(0.633,1) and an independent Z iid U(0,1)

```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)

z <- runif(nsims, 0, 1)
#mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)

s.ylim <- c(0,0.6)
s.xlim <- c(0,12)
par(mfcol=c(4,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(-0.1,1.1), xlim=c(-0.1,1.1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)+log(1/A)", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
           3,
           aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)


plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y)+log(1/A))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

It looks like we need more tightening from Z. Let's tinker.  Instead of multiplying by 1/2 on average, perhaps we need to multiply by 1/3 on average?  Let's leave Z as a uniform, with positive values smaller than 1 that average to a 1/3.  Let's replace `z<-runif(nsims, 0, 1)` with `z<-runif(nsims, 0, 2/3)` in the code:

```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)

z <- runif(nsims, 0, 2/3)
#mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)

s.ylim <- c(0,0.6)
s.xlim <- c(0,12)
par(mfcol=c(4,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0.0,2.0), xlim=c(-0.1,1.1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)+log(1/A)", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
           3,
           aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y)+log(1/A))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

While that was fun, this modification (shortening the range of the uniform) does not quite seem to "recover" the distribution of log(1/X).  It seems we needed more Z values that are smaller to fill in the part of the density near 0.  

There's another way to get Z to be "1/3 on average".  That is, we could draw two uniforms, V ~ uniform(0,1) and W ~ uniform(0,1) and let Z=min(V,W) (This insight was shown by Dr. Mihai Nica's [follow-up video](https://www.youtube.com/watch?v=Zx5T_IrNhUE).
).  Note, this is the same as letting Z ~ beta(1,**3**-1).  The **3** is bolded, because this is the number of exponentials that are being summed. This gives us a way to generalize to **K** exponentials being summed.  

```{r, include=TRUE, eval=TRUE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)


v <- runif(nsims,0,1)
w <- runif(nsims,0,1)
z <- matrixStats::rowMins(cbind(v,w))
#mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)

s.ylim <- c(0,0.6)
s.xlim <- c(0,12)
par(mfcol=c(4,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0.0,2.0), xlim=c(-0.1,1.1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)+log(1/A)", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
           3,
           aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y)+log(1/A))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

* nailed it!

Let's try it for summing 10 exponentials.

This means we need Z to be "1/10 on average".  That is, we could draw 9 uniforms let Z be the minimum of those 9 uniforms.  This is the same as letting Z ~ beta(1,**10**-1).  The **10** is bolded, because this is the number of exponentials we're summing, and it generalizes to any positive integer.

Be mindful of the x-axis and y-axis limits -- they are not the same for every plot!

```{r, include=TRUE, eval=TRUE, echo=FALSE, fig.height=15}
set.seed(1)
nsims <- nsim.switch
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)

b <- rbeta(nsims, aa_x, bb_x)
c <- rbeta(nsims, aa_y, bb_y)
d <- rbeta(nsims, aa_x, bb_x)

e <- rbeta(nsims, aa_x, bb_x)
f <- rbeta(nsims, aa_y, bb_y)
g <- rbeta(nsims, aa_x, bb_x)

h <- rbeta(nsims, aa_x, bb_x)


z <- rbeta(nsims, 1, 9)
#mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)

s.ylim <- c(0,0.6)
s.xlim <- c(0,12)
par(mfcol=c(11,3), mai=c(0.3,0.3,0.3,0.3))


hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)



hist(log(1/b), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/B)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/c), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/C)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/d), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/D)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)


hist(log(1/e), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/E)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/f), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/F)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/g), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/G)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/h), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/H)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)





hist(    z , freq=FALSE, breaks=50, ylim=c(0.0,10.0), xlim=c(-0.1,1.1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")


plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a)+
       log(1/b)+log(1/c)+log(1/d)+
       log(1/e)+log(1/f)+log(1/g)+
       log(1/h)
     , freq=FALSE, breaks=50, ylim=s.ylim, xlim=c(0,36), 
     main="log(1/(XYABCDEFGH))", xlab="",ylab="")

lines(seq(0, 36,0.01 ),
      dgamma(seq(0, 36,0.01 ),
           10,
           aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")


plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)+
       log(1/b)+log(1/c)+log(1/d)+
       log(1/e)+log(1/f)+log(1/g)+
       log(1/h)
     ), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/(XYABCDEFGH))", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```


<!-- This is where turning to theory might save us some time. -->

<!-- <!-- Green note book page 88 and 89 --> -->

<!--   * The sum of 3 iid Exponential($\alpha$) variables will be distributed as Gamma(3,$\alpha$). -->

<!--   * If W ~ Gamma(3,lambda) then cW ~ Gamma(3, lambda/c) -->

<!--   * I'll leave it as an exercise for the reader, but the two best hopes for a choice of distribution for Z in trying to get the computed quantity back to the original Exponential is Z ~ U(0,1) or Z ~ Beta(2,1).  Either case ends up with Z(log(1/X)+log(1/Y)+log(1/A)) having a density that looks like an exponential density multiplied by extra stuff: -->

<!--     * $\lambda e^{-\lambda x} \times \left[ \frac{1+ \lambda x}{2} \right]$ or -->
<!--     * $\lambda e^{-\lambda x} \times \left[ \lambda x \right]$ -->

<!-- For kicks, I googled this problem of transforming Gamma(3,a) into Gamma(1,a) and got this from the AI results: -->

<!--   * A Gamma distribution times a Gamma distribution will result in an exponential distribution if the shape parameter of both Gamma distributions is 1, and their rate parameters are the same. In other words, if X ~ Gamma(1, ) and Y ~ Gamma(1, ), then their product X*Y ~ Exponential().  -->

<!--   * Therefore \(Gamma(3,\alpha )\) cannot be transformed into \(Exponential(\alpha )\). \(Gamma(1,\alpha )\) is equal to \(Exponential(\alpha )\). -->

<!-- One can tinker and see how close they can get but the theory says it will be inexact. -->


<!--   * go through green books examples of trying to isolate the 'x' and showing that it is going to show up either way for n=3 and then plot! -->



```{r, include=FALSE, eval=FALSE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch ##6e5
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)

z <- runif(nsims,0,1)
#z <- rgamma(nsims, 0.9, 3)
##z <- rgamma(nsims, 3, aa_x)
#z <- invgamma::rinvgamma(nsims, 3, aa_x)
mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)


s.ylim <- c(0,0.6)
s.xlim <- c(0,12)

par(mfcol=c(4,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(    z , freq=FALSE, breaks=50, ylim=c(0,1.2), xlim=c(-0.1,1.1), 
     main="Z", xlab="",ylab="")




plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)+log(1/A)", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
           3,
           aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y)+log(1/A))", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)




lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      0.5*(1+aa_x*seq(s.xlim[1], s.xlim[2],0.01 )) * 
        dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="gold"
)


plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

<!-- See page 90 of green notebook. 2025-05-22. -->

<!-- As an exercize, one can solve for the density if Z is InverseGamma(az,bz) and then try to select az,bz >0  that gives the closest match to an exponential density. -->

<!-- One can even try Z ~ InverseGamma(.9,.2) (below), but the computed quantity is never going to be an Exponential.  So I guess the sum of two exponentials involved in this result is special and doesn't generalize to 3, i.e., while (XY)^Z is Uniform, (XYA)^Z won't be. -->


```{r, include=FALSE, eval=FALSE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch ##6e5
aa_x <- 0.633
aa_y <- 0.633

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)

#z <- runif(nsims,0,1)
#z <- rgamma(nsims, 0.9, 3)
##z <- rgamma(nsims, 3, aa_x)
z <- invgamma::rinvgamma(nsims, .9, .2)
mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)


s.ylim <- c(0,0.6)
s.xlim <- c(0,12)

par(mfcol=c(4,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)


#hist(    z , freq=FALSE, breaks=50, ylim=c(0,1.2), xlim=c(-0.1,1.1), 
#     main="Z", xlab="",ylab="")

hist(z, freq=FALSE, breaks=500000, ylim=c(0,4), xlim=s.xlim, 
     main="Z", xlab="",ylab="")



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)+log(1/A)", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
           3,
           aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)), freq=FALSE, breaks=500000, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y)+log(1/A))", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)




# lines(seq(s.xlim[1], s.xlim[2],0.01 ),
#       0.5*(1+aa_x*seq(s.xlim[1], s.xlim[2],0.01 )) * 
#         dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
#            aa_x),
#       lwd=overlaid.dens.lwd,
#       col="pink"
# )
# 

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

<!-- But wait! Dr. Mihai Nica saves the day again. If Z is min of two uniforms, then the relation will hold for sum of three exponentials with a commmon rate! [https://www.youtube.com/watch?v=Zx5T_IrNhUE](follow-up vid) -->

<!--   * Z~min(V,W) where V,W iid U(0,1) -->
<!--   * wait... that just makes Z ~ beta(1,2) -->

```{r, include=FALSE, eval=FALSE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch ##6e5
aa_x <- 2
aa_y <- 2

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)

v <- runif(nsims,0,1)
w <- runif(nsims,0,1)



z <- matrixStats::rowMins(cbind(v,w))
mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)


s.ylim <- c(0,1.2)
s.xlim <- c(0,12)

par(mfcol=c(4,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)


hist(    z , freq=FALSE, breaks=50, ylim=c(0,3), xlim=c(-0.1,1.1),
    main="min(V,W)", xlab="",ylab="")

# hist(z, freq=FALSE, breaks=500000, ylim=c(0,4), xlim=s.xlim, 
#      main="Z", xlab="",ylab="")



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)+log(1/A)", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
           3,
           aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y)+log(1/A))", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)




# lines(seq(s.xlim[1], s.xlim[2],0.01 ),
#       0.5*(1+aa_x*seq(s.xlim[1], s.xlim[2],0.01 )) * 
#         dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
#            aa_x),
#       lwd=overlaid.dens.lwd,
#       col="pink"
# )
# 

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```

  <!-- * What about 5 exponentials? -->
  <!-- * do I take the min of 4 uniforms? -->
  <!-- * Z~min(m,n,o,p) where m,n,o,p iid U(0,1) -->
  <!-- * wait... that just makes Z ~ beta(1,4) -->

```{r, include=FALSE, eval=FALSE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch ##6e5
aa_x <- 2
aa_y <- 2

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)
b <- rbeta(nsims, aa_y, bb_y)
c <- rbeta(nsims, aa_x, bb_x)


m <- runif(nsims,0,1)
n <- runif(nsims,0,1)
o <- runif(nsims,0,1)
p <- runif(nsims,0,1)



z <- matrixStats::rowMins(cbind(m,n,o,p))
mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)


s.ylim <- c(0,1.2)
s.xlim <- c(0,12)

par(mfcol=c(4,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)


hist(    z , freq=FALSE, breaks=50, ylim=c(0,5), xlim=c(-0.1,1.1),
    main="min(m,n,o,p)", xlab="",ylab="")

# hist(z, freq=FALSE, breaks=500000, ylim=c(0,4), xlim=s.xlim, 
#      main="Z", xlab="",ylab="")



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a)+log(1/b)+log(1/c), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/(XYABC))", xlab="",ylab="")

# lines(seq(s.xlim[1], s.xlim[2],0.01 ),
#       dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
#            3,
#            aa_x),
#       lwd=overlaid.dens.lwd,
#       col="skyblue"
# )
# 


plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)+log(1/b)+log(1/c)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/(XYABC)))", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)




# lines(seq(s.xlim[1], s.xlim[2],0.01 ),
#       0.5*(1+aa_x*seq(s.xlim[1], s.xlim[2],0.01 )) * 
#         dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
#            aa_x),
#       lwd=overlaid.dens.lwd,
#       col="pink"
# )
# 

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```


  <!-- * max(V,W)^B ... I can't get it to work. is it for the other computed quantity (xy)^Z?? remember the code below is for (1/x * 1/y)^z -->


```{r, include=FALSE, eval=FALSE, echo=FALSE}
set.seed(1)
nsims <- nsim.switch ##6e5
aa_x <- 1
aa_y <- 1

bb_x <- 1
bb_y <- 1

x <- rbeta(nsims, aa_x, bb_x)
y <- rbeta(nsims, aa_y, bb_y)
a <- rbeta(nsims, aa_x, bb_x)

v <- runif(nsims,0,1)
w <- runif(nsims,0,1)
b <- runif(nsims,0,1)


z <- matrixStats::rowMaxs(cbind(v,w))
mean(z)

s.xlim <- range(c(log(1/x),
                  log(1/y),
                  z,
                  log(1/x * 1/y),
                  z*log(1/x*1/y)
)
) #c(-10,0)#c(-4,2)


s.ylim <- c(0,1.2)
s.xlim <- c(0,12)

par(mfcol=c(4,3), mai=c(0.3,0.3,0.3,0.3))
hist(log(1/x), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/y), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/Y)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)

hist(log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/A)", xlab="",ylab="")
lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)


hist(    z^(1-b) , freq=FALSE, breaks=50, ylim=c(0,3), xlim=c(-0.1,1.1),
    main="max(V,W)^B", xlab="",ylab="")

# hist(z, freq=FALSE, breaks=500000, ylim=c(0,4), xlim=s.xlim, 
#      main="Z", xlab="",ylab="")



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(log(1/x)+log(1/y)+log(1/a), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="log(1/X)+log(1/Y)+log(1/A)", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dgamma(seq(s.xlim[1], s.xlim[2],0.01 ),
           3,
           aa_x),
      lwd=overlaid.dens.lwd,
      col="skyblue"
)



plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")
plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")

hist(z*(log(1/x)+log(1/y)+log(1/a)), freq=FALSE, breaks=50, ylim=s.ylim, xlim=s.xlim, 
     main="Z(log(1/X)+log(1/Y)+log(1/A))", xlab="",ylab="")

lines(seq(s.xlim[1], s.xlim[2],0.01 ),
      dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
           aa_x),
      lwd=overlaid.dens.lwd,
      col="red"
)




# lines(seq(s.xlim[1], s.xlim[2],0.01 ),
#       0.5*(1+aa_x*seq(s.xlim[1], s.xlim[2],0.01 )) * 
#         dexp(seq(s.xlim[1], s.xlim[2],0.01 ),
#            aa_x),
#       lwd=overlaid.dens.lwd,
#       col="pink"
# )
# 

plot(NA,NA,axes=F,xlim=c(0,1),ylim=c(0,1),xlab="",ylab="")



```


All of these simulations and results are for a common $\alpha$.  We consider the case unequal $\alpha$ case in [part II of this topic](https://swihart.github.io/mvpd/articles/xy_to_the_z_part_ii.html).

#### Miscellany / Notes to self / Stubs for future ideas

  *   [Proof of -ln(X) being an Exponential](https://math.stackexchange.com/a/3173387/180716)

  * [Is this transformation of beta relevant for a=0, b=1?](https://math.stackexchange.com/a/4039033/180716)
  
  * [Keep in back pocket for generalizing Uniform...U(-1,1)](https://stats.stackexchange.com/a/461337/35034)

  * Looking at the [inductive form](https://math.stackexchange.com/a/3485159/180716), may provide insight as to why Z may not have a "recovering" distribution for a sum of more than 2 exponentials.
